<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Collaborative Editor</title>

    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            background-color: #f8f9fa;
        }
        .editor-container {
            max-width: 800px;
            margin: 2rem auto;
            background: white;
            padding: 2rem;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            border-radius: 8px;
            min-height: 1120px; /* Close to A4 (297mm x 210mm) */
        }
        .toolbar {
            margin-bottom: 1rem;
        }
        #editor {
            width: 100%;
            height: 100%;
            border: none;
            resize: none;
            outline: none;
            font-family: 'Arial', sans-serif;
            font-size: 16px;
            padding: 1rem;
            background: transparent;
            overflow-y: auto;
        }
        .shape {
            position: absolute;
            border: 2px dashed #007bff;
            background: rgba(0, 123, 255, 0.1);
            pointer-events: none;
        }
        @keyframes blink {
            0% { opacity: 1; }
            50% { opacity: 0; }
            100% { opacity: 1; }
        }
        .cursor {
            animation: blink 1s step-start infinite;
        }
    </style>
</head>

<body>

<div class="container">
    <div class="editor-container position-relative">

        <div class="toolbar d-flex flex-wrap gap-2 mb-3">
            <select id="fontSelect" class="form-select form-select-sm" style="width: auto;">
                <option value="Arial">Arial</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
                <option value="Verdana">Verdana</option>
            </select>

            <input type="color" id="colorPicker" class="form-control form-control-color" title="Pick text color">

            <button id="boldBtn" class="btn btn-sm btn-outline-primary">Bold</button>
            <button id="italicBtn" class="btn btn-sm btn-outline-primary">Italic</button>
            <button id="underlineBtn" class="btn btn-sm btn-outline-primary">Underline</button>

            <button id="insertImageBtn" class="btn btn-sm btn-outline-success">Insert Image</button>

            <div class="dropdown">
                <button class="btn btn-sm btn-outline-secondary dropdown-toggle" type="button"
                        data-bs-toggle="dropdown">
                    Insert Shape
                </button>
                <ul class="dropdown-menu">
                    <li><a class="dropdown-item" href="#" onclick="startDrawing('rectangle')">Rectangle</a></li>
                    <li><a class="dropdown-item" href="#" onclick="startDrawing('circle')">Circle</a></li>
                </ul>
            </div>
        </div>

        <div id="drawingArea" class="position-relative" style="min-height:1000px;">
            <div contenteditable="true" id="editor"></div>
        </div>

        <div id="sessionLabel" class="session-label position-absolute"></div>

    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

<script>
    const sessionData = JSON.parse(sessionStorage.getItem('sessionData'));

    if (!sessionData) {
        alert('No session information found. Please go back and create/join a session.');
        window.location.href = '/';
    } else {
        const { sessionId, username, color } = sessionData;

        const socket = new WebSocket(`ws://${location.host}/edit`);

        socket.addEventListener("open", () => {
            socket.send(JSON.stringify({
                type: "init",
                sessionId,
                username,
                userColor: color
            }));
        });

        const userId = "user-" + Math.floor(Math.random() * 10000);
        const userColor = color || "#000000";

        const editor = document.getElementById("editor");

        let lastValue = "";
        let selfChange = false;

        fetch(`/content?session=${sessionId}`)
            .then(res => res.text())
            .then(text => {
            editor.innerHTML = text.replace(/\n/g, "<br>");
            lastValue = editor.innerHTML;
        });

        let timeoutId;
        const debounceSave = (newValue) => {
            clearTimeout(timeoutId);
            timeoutId = setTimeout(() => {
                saveContentToServer(newValue);
            }, 500); // 500ms delay for throttling the server
        };

        let inputTimeout;
        editor.addEventListener("input", () => {
            if (selfChange) {
                selfChange = false;
                return;
            }

            if (inputTimeout) {
                clearTimeout(inputTimeout);
            }

            inputTimeout = setTimeout(() => {
                const newValue = editor.innerHTML;
                const diff = generateDiff(lastValue, newValue);
                const cursorPos = getCaretCharacterOffsetWithin(editor);
                lastValue = newValue;

                socket.send(JSON.stringify({
                    type: "update",
                    userId,
                    username,
                    userColor,
                    sessionId,
                    start: diff.start,
                    end: diff.end,
                    inserted: diff.inserted,
                    cursor: cursorPos
                }));

                debounceSave(newValue);
            }, 100); // wait some ms until getting difference
        });

        const messageQueue = [];
        let isProcessing = false;

        // process each message into a queue
        socket.addEventListener("message", (event) => {
            const data = JSON.parse(event.data);

            if (data.userId === userId) return;

            messageQueue.push(data);
            processQueue();
        });

        function processQueue() {
            if (isProcessing) return;
            if (messageQueue.length === 0) return;

            isProcessing = true;
            const data = messageQueue.shift();

            if (data.type === "update") {
                selfChange = true;

                applyDiffToEditor(data);
                showRemoteCursor(data.userId, data.cursor, data.userColor, data.username);

                lastValue = editor.innerHTML;
            } else if (data.type === "user-left") {
                if (cursors[data.userId]) {
                    cursors[data.userId].cursor.remove();
                    cursors[data.userId].label.remove();
                    delete cursors[data.userId];
                }
            }

            isProcessing = false;
            processQueue();
        }

        function generateDiff(oldText, newText) {
            let start = 0;
            while (start < oldText.length && start < newText.length && oldText[start] === newText[start]) {
                start++;
            }

            let oldEnd = oldText.length - 1;
            let newEnd = newText.length - 1;
            while (oldEnd >= start && newEnd >= start && oldText[oldEnd] === newText[newEnd]) {
                oldEnd--;
                newEnd--;
            }

            return {
                start,
                end: oldEnd + 1,
                inserted: newText.slice(start, newEnd + 1)
            };
        }

        function applyDiffToEditor(diff) {
            const value = editor.innerHTML;
            editor.innerHTML = value.slice(0, diff.start) + diff.inserted + value.slice(diff.end);
        }

        function getCaretCharacterOffsetWithin(element) {
            let caretOffset = 0;
            const selection = window.getSelection();
            if (selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                const preCaretRange = range.cloneRange();
                preCaretRange.selectNodeContents(element);
                preCaretRange.setEnd(range.endContainer, range.endOffset);
                caretOffset = preCaretRange.toString().length;
            }
            return caretOffset;
        }

        const cursors = {}; // Track remote cursors

        function showRemoteCursor(userId, position, color, username) {
            const cursorPos = Math.min(position, editor.innerText.length); // ensure the cursor pos is within bounds

            // Remove old cursor if it exists
            if (cursors[userId]) {
                cursors[userId].cursor.remove();
                cursors[userId].label.remove();
            }

            const range = document.createRange();
            const selection = window.getSelection();

            let node = editor.firstChild || editor;
            let offset = cursorPos;

            // Traverse the nodes to find the correct text node and offset
            while (node) {
                if (node.nodeType === Node.TEXT_NODE) {
                    if (node.length >= offset) {
                        range.setStart(node, offset); // set cursor inside the correct text node
                        break;
                    } else {
                        offset -= node.length; // reduce offset if this node is too short
                    }
                }
                node = node.nextSibling; // move to next sibling node
            }

            // If no valid node found, return early (no cursor)
            if (!node) return;

            range.collapse(true); // collapse the range to a single point (cursor)

            const rect = range.getBoundingClientRect();
            const editorRect = editor.getBoundingClientRect();

            // Create the cursor element
            const cursor = document.createElement('div');
            cursor.className = 'cursor';
            cursor.style.position = 'absolute';
            cursor.style.left = (rect.left - editorRect.left) + 'px';
            cursor.style.top = (rect.top - editorRect.top) + 'px';
            cursor.style.width = '2px';
            cursor.style.height = '1em';
            cursor.style.backgroundColor = color;
            cursor.style.animation = 'blink 1s step-start 0s infinite';
            cursor.style.zIndex = '1000';

            // Create the name label
            const label = document.createElement('div');
            label.className = 'cursor-label';
            label.innerText = username;
            label.style.position = 'absolute';
            label.style.left = (rect.left - editorRect.left - 2) + 'px';
            label.style.top = (rect.top - editorRect.top - 20) + 'px'; // above the cursor
            label.style.backgroundColor = color;
            label.style.color = 'white';
            label.style.padding = '2px 4px';
            label.style.fontSize = '12px';
            label.style.borderRadius = '4px';
            label.style.whiteSpace = 'nowrap';
            label.style.zIndex = '1001';

            // Append cursor and label to the editor container
            editor.parentElement.appendChild(cursor);
            editor.parentElement.appendChild(label);

            cursors[userId] = { cursor, label }; // Track the cursor and label for this user

            // Ensure the cursor is visible by scrolling it into view if needed
            const cursorBottom = rect.top + rect.height;
            const editorBottom = editor.getBoundingClientRect().bottom;

            if (cursorBottom > editorBottom) {
                // Scroll editor to bring the cursor into view if it's out of bounds
                editor.scrollTop += (cursorBottom - editorBottom);
            } else if (rect.top < editorRect.top) {
                // Scroll editor to bring the cursor into view if it's above the editor
                editor.scrollTop -= (editorRect.top - rect.top);
            }
        }

        function saveContentToServer(content) {
            fetch(`/save-content?session=${sessionId}`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json"
                },
                body: JSON.stringify({ content })
            }).then(response => {
                if (!response.ok) {
                    throw new Error("Failed to save content");
                }
                console.log("Content saved successfully.");
            }).catch(err => console.error("Save content error:", err));
        }

        // Toolbar actions
        document.getElementById("fontSelect").addEventListener("change", (e) => {
            document.execCommand('fontName', false, e.target.value);
        });

        document.getElementById("colorPicker").addEventListener("input", (e) => {
            document.execCommand('foreColor', false, e.target.value);
        });

        document.getElementById("boldBtn").addEventListener("click", () => {
            document.execCommand('bold');
        });

        document.getElementById("italicBtn").addEventListener("click", () => {
            document.execCommand('italic');
        });

        document.getElementById("underlineBtn").addEventListener("click", () => {
            document.execCommand('underline');
        });

        document.getElementById("insertImageBtn").addEventListener("click", () => {
            const url = prompt("Enter Image URL:");
            if (url) {
                document.execCommand('insertImage', false, url);
            }
        });

        // Drawing shapes
        let isDrawing = false;
        let shapeType = null;
        let shapeElement = null;
        const drawingArea = document.getElementById('drawingArea');

        function startDrawing(type) {
            shapeType = type;
            isDrawing = true;
        }

        drawingArea.addEventListener('mousedown', (e) => {
            if (!isDrawing) return;

            shapeElement = document.createElement('div');
            shapeElement.classList.add('shape');
            shapeElement.style.left = e.offsetX + 'px';
            shapeElement.style.top = e.offsetY + 'px';
            shapeElement.dataset.startX = e.offsetX;
            shapeElement.dataset.startY = e.offsetY;

            drawingArea.appendChild(shapeElement);

            drawingArea.addEventListener('mousemove', resizeShape);
            drawingArea.addEventListener('mouseup', finishShape);
        });

        function resizeShape(e) {
            if (!shapeElement) return;

            const startX = parseInt(shapeElement.dataset.startX);
            const startY = parseInt(shapeElement.dataset.startY);
            const width = e.offsetX - startX;
            const height = e.offsetY - startY;

            shapeElement.style.width = Math.abs(width) + 'px';
            shapeElement.style.height = Math.abs(height) + 'px';
            shapeElement.style.left = (width < 0 ? e.offsetX : startX) + 'px';
            shapeElement.style.top = (height < 0 ? e.offsetY : startY) + 'px';

            if (shapeType === 'circle') {
                shapeElement.style.borderRadius = '50%';
            } else {
                shapeElement.style.borderRadius = '0';
            }
        }

        function finishShape(e) {
            isDrawing = false;
            shapeType = null;
            shapeElement = null;
            drawingArea.removeEventListener('mousemove', resizeShape);
            drawingArea.removeEventListener('mouseup', finishShape);
        }
    }

    // Retrieve sessionId from sessionData
    const sessionId = sessionData.sessionId;

    // Get the element for the session label
    const sessionLabel = document.getElementById("sessionLabel");

    // Set the content of the session label
    sessionLabel.innerHTML = `Session ID: ${sessionId}`;

    // Style it to center it at the bottom
    sessionLabel.style.left = '50%';
    sessionLabel.style.bottom = '20px';
    sessionLabel.style.transform = 'translateX(-50%)'; // to center the label horizontally
    sessionLabel.style.fontSize = '14px';
    sessionLabel.style.color = '#007bff'; // You can customize this color
    sessionLabel.style.fontWeight = 'bold';
    sessionLabel.style.backgroundColor = 'rgba(255, 255, 255, 0.7)'; // Optional: a background for better visibility
    sessionLabel.style.padding = '5px 10px';
    sessionLabel.style.borderRadius = '5px';
</script>

</body>
</html>
